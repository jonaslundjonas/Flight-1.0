<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Sim v12.2 - carMaterials Fix (Three.js)</title>
    <style>
        /* CSS Styles remain the same */
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; color: white;}
        canvas { display: block; }
        #info { position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.6); padding: 10px; border-radius: 5px; font-size: 1.1em; min-width: 150px; z-index: 10; }
        #info div { margin-bottom: 5px; }
        #info span { font-weight: bold; color: #ffcc00; }
        #lives-display { color: #ff4444; }
        #controls-info { position: absolute; bottom: 10px; left: 10px; background-color: rgba(0,0,0,0.6); padding: 8px; font-size: 0.9em; border-radius: 3px; z-index: 10;}
        #game-over-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); color: white; font-size: 2.5em; text-align: center; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        #game-over-text { margin-bottom: 20px; }
        #final-score { font-size: 0.8em; margin-bottom: 30px; color: #ffcc00; }
        #high-score-title { font-size: 0.7em; margin-bottom: 10px; text-decoration: underline; }
        #high-score-list { font-size: 0.5em; list-style: none; padding: 0; margin-bottom: 30px; min-width: 200px; text-align: left; background-color: rgba(255,255,255,0.1); padding: 10px; border-radius: 5px; }
        #high-score-list li { display: flex; justify-content: space-between; margin-bottom: 5px;}
        #high-score-list li span:first-child { margin-right: 15px; }
        #game-over-overlay button { margin-top: 20px; padding: 15px 30px; font-size: 0.5em; cursor: pointer; background-color: #eee; border: none; border-radius: 5px; color: #333; }
    </style>
</head>
<body>
    <!-- Info Display -->
    <div id="info">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives-display">3</span></div>
        <div>Alt: <span id="altitude">0</span> m</div>
        <div>Spd: <span id="speed">0</span> m/s</div>
        <div>Thr: <span id="thrust">0</span>%</div>
    </div>
    <!-- Controls Info -->
     <div id="controls-info">
        Controls: [↑↓] Pitch | [←→] Roll | [W/S] Thrust | [A/D] Taxi | [C]+[←→] Strafe | [Space] Shoot
    </div>
    <!-- Game Over Screen -->
     <div id="game-over-overlay">
         <div id="game-over-text">GAME OVER</div>
         <div id="final-score">Final Score: <span id="final-score-value">0</span></div>
         <div id="high-score-title">High Scores</div>
         <ul id="high-score-list">
             <li><span>---</span> <span>0</span></li>
             <li><span>---</span> <span>0</span></li>
             <li><span>---</span> <span>0</span></li>
             <li><span>---</span> <span>0</span></li>
             <li><span>---</span> <span>0</span></li>
         </ul>
         <button id="restart-button">Restart Game</button>
     </div>

    <!-- Import map for Three.js ES Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Main script using modules -->
    <script type="module">
        // Created by Jonas Lund 2025

        // ========================================
        // Instructions:
        // - Fly the plane using keyboard controls.
        // - Avoid crashing into buildings, trees, cars, or birds.
        // - Shoot balloons (50 pts) and birds (150 pts) using Spacebar.
        // - Colliding directly with balloons gives 100 pts but doesn't cost a life.
        // - Use 'C' + Left/Right Arrows to strafe sideways (only in air).
        // - You have 3 lives. Game Over when lives reach 0.
        // ========================================

        import * as THREE from 'three';

        // --- Core Components & Game Objects ---
        let scene, camera, renderer, clock;
        let planeMesh = null; let groundMesh;
        let sceneryObjects = [], clouds = [], roads = [], balloons = [], cars = [], birds = [], projectiles = [];
        let explosionParticles = [];

        // --- Game State ---
        let lives = 3; let score = 0; let gameState = 'playing';
        const POINTS_PER_BALLOON_HIT = 100; const POINTS_PER_BALLOON_SHOT = 50; const POINTS_PER_BIRD_SHOT = 150;
        const CRASH_RESET_DELAY = 2500; const HIGH_SCORE_KEY = 'flightSimHighScores'; let highScores = [];

        // --- Materials & Geometry --- << ADDED carMaterials BACK >>
        const houseMaterials = [ new THREE.MeshStandardMaterial({ color: 0xcc8855, roughness: 0.8, metalness: 0.1 }), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.7, metalness: 0.1 }), new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.7, metalness: 0.1 }),];
        const skyscraperMaterial = new THREE.MeshStandardMaterial({ color: 0x667788, roughness: 0.6, metalness: 0.3 });
        const treeTrunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }); const treeCanopyMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57, roughness: 0.8 });
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 }); let cloudMaterial;
        const balloonMaterials = [ new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4, metalness: 0.2 }), new THREE.MeshStandardMaterial({ color: 0x0000ff, roughness: 0.4, metalness: 0.2 }), new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.4, metalness: 0.2 }), new THREE.MeshStandardMaterial({ color: 0xffff00, roughness: 0.4, metalness: 0.2 }), new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.4, metalness: 0.2 }),];
        const balloonGeometry = new THREE.SphereGeometry(8, 16, 12);
        const carMaterials = [ // *** THIS ARRAY WAS MISSING ***
            new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.5 }), // Dark Red
            new THREE.MeshStandardMaterial({ color: 0x0000aa, roughness: 0.5 }), // Dark Blue
            new THREE.MeshStandardMaterial({ color: 0x00aa00, roughness: 0.5 }), // Dark Green
            new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.5 }), // Light Grey
            new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 }), // Dark Grey
        ];
        const birdMaterial = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        const explosionMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 });
        const explosionGeometry = new THREE.SphereGeometry(0.8, 6, 4);
        const projectileGeometry = new THREE.SphereGeometry(0.5, 6, 4); const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffee00 });

        // --- Plane State & Physics --- (Unchanged)
        const MIN_ALTITUDE = 1.0; const START_ALTITUDE = 100.0; const INITIAL_FORWARD_SPEED = 25.0;
        const planeState = { position: new THREE.Vector3(0, MIN_ALTITUDE + START_ALTITUDE, 0), velocity: new THREE.Vector3(0, 0, -INITIAL_FORWARD_SPEED), quaternion: new THREE.Quaternion(), thrust: 1.0, speed: INITIAL_FORWARD_SPEED, pitchSpeed: 0, rollSpeed: 0, yawSpeed: 0, };
        const planeCollisionBox = new THREE.Box3(); const PLANE_BOX_SIZE = new THREE.Vector3(10, 2, 8);
        const PLANE_COLLISION_RADIUS = 3;

        // --- Constants --- << Increased CRAB_FORCE >> (Control rates remain hyper-fast)
        const GRAVITY = 9.81 * 0.03; const MAX_THRUST_FORCE = 1.0; const LIFT_COEFFICIENT = 0.0035; const DRAG_COEFFICIENT = 0.0004;
        const PITCH_CONTROL_RATE = 0.042; const ROLL_CONTROL_RATE = 0.045; const YAW_FROM_ROLL_FACTOR = 0.0105; const ANGULAR_DAMPING = 0.92;
        const MIN_SPEED_FOR_LIFT = 7.0; const GROUND_FRICTION = 0.95; const TAXI_YAW_RATE = 0.075; const GROUND_LEVELING_FACTOR = 0.08;
        const CRAB_FORCE = 50.0; // Increased from previous attempt
        const PROJECTILE_SPEED = 150.0; const SHOOT_COOLDOWN = 150; let lastShotTime = 0;

        // --- Input Handling ---
        const keysPressed = {};

        // --- Environment Generation Constants --- (Unchanged)
        const SCENERY_SPAWN_DISTANCE=700; const SCENERY_DESPAWN_DISTANCE=150; const SCENERY_AREA_WIDTH=400; const MAX_SCENERY_OBJECTS=50; const SCENERY_SPAWN_INTERVAL=0.22; let timeSinceLastScenerySpawn=0;
        const CLOUD_SPAWN_ALT_MIN=250; const CLOUD_SPAWN_ALT_MAX=600; const CLOUD_SPAWN_RADIUS=800; const CLOUD_DESPAWN_RADIUS=1200; const MAX_CLOUDS=25; const CLOUD_SPAWN_INTERVAL=0.8; let timeSinceLastCloudSpawn=0;
        const BALLOON_SPAWN_ALT_MIN=30; const BALLOON_SPAWN_ALT_MAX=400; const BALLOON_SPAWN_RADIUS=600; const BALLOON_DESPAWN_RADIUS=900; const MAX_BALLOONS=18; const BALLOON_SPAWN_INTERVAL=1.4; let timeSinceLastBalloonSpawn=0;
        const ROAD_LENGTH=4000; const ROAD_WIDTH=10; const ROAD_GRID_SPACING=250; const roadY = 0.05;
        const MAX_CARS=12; const CAR_SPEED=25; const CAR_SPAWN_INTERVAL=0.6; let timeSinceLastCarSpawn=0; const CAR_SPAWN_DISTANCE_AHEAD=500; const CAR_DESPAWN_DISTANCE_BEHIND=100; const CAR_DESPAWN_DISTANCE_SIDE=300;
        const MAX_BIRDS=15; const BIRD_SPEED_MIN=15; const BIRD_SPEED_MAX=30; const BIRD_SPAWN_INTERVAL=1.2; let timeSinceLastBirdSpawn=0; const BIRD_SPAWN_ALT_MIN=50; const BIRD_SPAWN_ALT_MAX=300; const BIRD_SPAWN_RADIUS=700; const BIRD_DESPAWN_RADIUS=1000; const BIRD_FLAP_SPEED=15;

        // --- HTML Elements --- (Unchanged)
        const scoreDisplay=document.getElementById('score'); const livesDisplay=document.getElementById('lives-display'); const altitudeDisplay=document.getElementById('altitude'); const speedDisplay=document.getElementById('speed'); const thrustDisplay=document.getElementById('thrust');
        const gameOverOverlay = document.getElementById('game-over-overlay'); const restartButton = document.getElementById('restart-button');
        const finalScoreValue = document.getElementById('final-score-value'); const highScoreList = document.getElementById('high-score-list');

        // --- Bounding Box Helpers ---
        const objectBox = new THREE.Box3(); const projectileBox = new THREE.Box3();

        // --- Initialization --- (Unchanged from v11.4)
        function init() { console.log("START: init()"); try { clock = new THREE.Clock(); scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 250, 1200); camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2500); camera.position.set(0, START_ALTITUDE + 20, 50); camera.lookAt(scene.position); renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); console.log("Renderer created."); const ambL=new THREE.AmbientLight(0xffffff,0.7); scene.add(ambL); const dirL=new THREE.DirectionalLight(0xffffff,0.9); dirL.position.set(100,150,100); dirL.castShadow=true; /* ... shadow params ... */ scene.add(dirL); console.log("Lighting added."); const gGeo=new THREE.PlaneGeometry(5000,5000); const gMat=new THREE.MeshStandardMaterial({color:0x3c7a40,side:THREE.DoubleSide}); groundMesh=new THREE.Mesh(gGeo,gMat); groundMesh.rotation.x=-Math.PI/2; groundMesh.receiveShadow=true; groundMesh.renderOrder=-1; scene.add(groundMesh); console.log("Ground added."); planeMesh = createPlaneMesh(); planeMesh.castShadow = true; scene.add(planeMesh); console.log("Plane mesh created and added."); setupRoads(); cloudMaterial=new THREE.SpriteMaterial({map:createCloudTexture(),transparent:true,opacity:0.6,blending:THREE.AdditiveBlending,sizeAttenuation:true,depthWrite:false}); console.log("Roads and cloud material setup."); window.addEventListener('resize',onWindowResize,false); document.addEventListener('keydown',(e)=>{ if(gameState==='playing') keysPressed[e.code]=true; if(e.code==='Space'&&gameState==='playing'){handleShooting();}}); document.addEventListener('keyup',(e)=>{keysPressed[e.code]=false;}); restartButton.addEventListener('click', restartGame); console.log("Event listeners added."); highScores = loadHighScores(); setInitialGameState(); console.log("END: init() successful."); animate(); } catch (error) { console.error("CRITICAL ERROR during init():", error); document.body.innerHTML = `<div style="color: red; font-size: 1.5em; padding: 20px;">Initialization Error: Check Console (F12) for details.<br>${error}</div>`; } }

        // --- Create Helper Functions ---
        function createPlaneMesh() { /* ... unchanged ... */ const group=new THREE.Group();const mainMat=new THREE.MeshStandardMaterial({color:0xadb5bd,metalness:0.3,roughness:0.6});const wingMat=new THREE.MeshStandardMaterial({color:0xced4da,metalness:0.2,roughness:0.7});const fG=new THREE.BoxGeometry(1.5,1.5,10);group.add(new THREE.Mesh(fG,mainMat));const wG=new THREE.BoxGeometry(12,0.3,3);const w=new THREE.Mesh(wG,wingMat);w.position.z=-1;group.add(w);const tFG=new THREE.BoxGeometry(0.3,3,1.5);const tF=new THREE.Mesh(tFG,wingMat);tF.position.set(0,1.5,4);group.add(tF);const tWG=new THREE.BoxGeometry(5,0.2,1.5);const tW=new THREE.Mesh(tWG,wingMat);tW.position.set(0,0.2,4.5);group.add(tW);const nG=new THREE.ConeGeometry(0.75,1.5,8);const n=new THREE.Mesh(nG,mainMat);n.rotation.x=Math.PI/2;n.position.z=-5.75;group.add(n);group.scale.set(0.8,0.8,0.8);group.traverse((c)=>{if(c.isMesh)c.castShadow=true;});return group;}
        function createCloudTexture() { /* ... unchanged ... */ const can=document.createElement('canvas');can.width=128;can.height=128;const ctx=can.getContext('2d');const grad=ctx.createRadialGradient(64,64,0,64,64,64);grad.addColorStop(0,'rgba(255,255,255,0.8)');grad.addColorStop(0.5,'rgba(255,255,255,0.5)');grad.addColorStop(1,'rgba(255,255,255,0)');ctx.fillStyle=grad;ctx.fillRect(0,0,128,128);return new THREE.CanvasTexture(can);}
        function createBirdMesh() { /* ... unchanged ... */ const group=new THREE.Group();const bodyGeo=new THREE.ConeGeometry(0.3,1.5,6);const body=new THREE.Mesh(bodyGeo,birdMaterial);body.rotation.x=Math.PI/2;group.add(body);const wingShape=new THREE.Shape();wingShape.moveTo(-0.2,0);wingShape.lineTo(2.5,0.4);wingShape.lineTo(2.5,-0.4);wingShape.closePath();const wingGeo=new THREE.ShapeGeometry(wingShape);const wingLeft=new THREE.Mesh(wingGeo,birdMaterial);wingLeft.position.z=-0.3;wingLeft.rotation.y=-0.1;group.add(wingLeft);const wingRight=new THREE.Mesh(wingGeo,birdMaterial);wingRight.scale.x=-1;wingRight.position.z=-0.3;wingRight.rotation.y=0.1;group.add(wingRight);group.userData.wings=[wingLeft,wingRight];group.scale.set(1.5,1.5,1.5);return group;}
        // --- Better Car Model --- (Uses carMaterials now)
        function createCarMesh() { const group=new THREE.Group(); const bodyHeight=1.2; const bodyWidth=2.2; const bodyLength=4.5; const cabinHeight=0.8; const cabinOffsetZ=-0.3; const wheelRadius=0.4; const wheelWidth=0.3; const wheelOffset=1.1; const carBodyMat=carMaterials[Math.floor(Math.random()*carMaterials.length)]; const wheelMat=new THREE.MeshStandardMaterial({color:0x222222,roughness:0.8}); const bodyGeo=new THREE.BoxGeometry(bodyWidth,bodyHeight,bodyLength); const body=new THREE.Mesh(bodyGeo,carBodyMat); body.position.y=wheelRadius; group.add(body); const cabinGeo=new THREE.BoxGeometry(bodyWidth*0.85,cabinHeight,bodyLength*0.5); const cabin=new THREE.Mesh(cabinGeo,carBodyMat); cabin.position.y=wheelRadius+bodyHeight/2+cabinHeight/2; cabin.position.z=cabinOffsetZ; group.add(cabin); const wheelGeo=new THREE.CylinderGeometry(wheelRadius,wheelRadius,wheelWidth,12); const wheelPos=[{x:-wheelOffset,z:bodyLength*0.35},{x:wheelOffset,z:bodyLength*0.35},{x:-wheelOffset,z:-bodyLength*0.35},{x:wheelOffset,z:-bodyLength*0.35}]; wheelPos.forEach(pos=>{const wheel=new THREE.Mesh(wheelGeo,wheelMat); wheel.rotation.z=Math.PI/2; wheel.position.set(pos.x,wheelRadius,pos.z); group.add(wheel);}); group.castShadow=true; group.traverse(child=>{if(child.isMesh) child.castShadow=true;}); group.userData.yOffset=0; return group; }

        // --- Scenery Spawning --- (Unchanged logic)
        function spawnSceneryObject(spawnPos) { /* ... */ if (sceneryObjects.length >= MAX_SCENERY_OBJECTS) return; let mesh = null; const type=Math.random(); if(type<0.15){ const sx=Math.random()*15+10; const sy=Math.random()*150+100; const sz=Math.random()*15+10; const geo=new THREE.BoxGeometry(sx,sy,sz); mesh=new THREE.Mesh(geo,skyscraperMaterial); mesh.position.set(spawnPos.x,sy/2,spawnPos.z); mesh.userData.type='skyscraper';} else if(type<0.55){ const sx=Math.random()*6+4; const sy=Math.random()*10+5; const sz=Math.random()*6+4; const geo=new THREE.BoxGeometry(sx,sy,sz); const mat=houseMaterials[Math.floor(Math.random()*houseMaterials.length)]; mesh=new THREE.Mesh(geo,mat); mesh.position.set(spawnPos.x,sy/2,spawnPos.z); mesh.userData.type='house';} else { const th=Math.random()*8+4; const tr=th*(Math.random()*0.1+0.08); const ch=th*(Math.random()*0.8+0.6); const cr=tr*(Math.random()*4+3); const tGeo=new THREE.CylinderGeometry(tr*0.7,tr,th,8); const tMesh=new THREE.Mesh(tGeo,treeTrunkMaterial); const cGeo=new THREE.ConeGeometry(cr,ch,12); const cMesh=new THREE.Mesh(cGeo,treeCanopyMaterial); cMesh.position.y=th/2+ch/2.5; mesh=new THREE.Group(); mesh.add(tMesh); mesh.add(cMesh); mesh.position.set(spawnPos.x,th/2,spawnPos.z); mesh.userData.type='tree';} if (mesh) { mesh.castShadow=true; mesh.receiveShadow=true; scene.add(mesh); sceneryObjects.push(mesh); } else { console.warn("Scenery mesh was not created in spawnSceneryObject"); } }

        // --- Other Spawning & Road Management --- (Unchanged logic)
        function spawnCloud() { /* ... */ if(clouds.length>=MAX_CLOUDS) return; const c=new THREE.Sprite(cloudMaterial); const s=Math.random()*80+60; c.scale.set(s,s,1); const a=Math.random()*Math.PI*2; const r=Math.random()*CLOUD_SPAWN_RADIUS; const sx=planeState.position.x+Math.cos(a)*r; const sz=planeState.position.z+Math.sin(a)*r; const sy=CLOUD_SPAWN_ALT_MIN+Math.random()*(CLOUD_SPAWN_ALT_MAX-CLOUD_SPAWN_ALT_MIN); c.position.set(sx,sy,sz); c.renderOrder=1; scene.add(c); clouds.push(c); }
        function spawnBalloon() { /* ... */ if(balloons.length>=MAX_BALLOONS) return; const mat=balloonMaterials[Math.floor(Math.random()*balloonMaterials.length)]; const bal=new THREE.Mesh(balloonGeometry,mat); bal.castShadow=true; const a=Math.random()*Math.PI*2; const r=Math.random()*BALLOON_SPAWN_RADIUS; const sx=planeState.position.x+Math.cos(a)*r; const sz=planeState.position.z+Math.sin(a)*r; const sy=BALLOON_SPAWN_ALT_MIN+Math.random()*(BALLOON_SPAWN_ALT_MAX-BALLOON_SPAWN_ALT_MIN); bal.position.set(sx,sy,sz); bal.userData.radius=balloonGeometry.parameters.radius; scene.add(bal); balloons.push(bal); }
        function setupRoads() { /* ... */ const geo=new THREE.PlaneGeometry(ROAD_WIDTH,ROAD_LENGTH); for(let i=0;i<4;i++){ const nsR=new THREE.Mesh(geo,roadMaterial); nsR.rotation.x=-Math.PI/2; nsR.receiveShadow=true; nsR.renderOrder=0; scene.add(nsR); roads.push({mesh:nsR,orientation:'NS'}); const ewR=new THREE.Mesh(geo,roadMaterial); ewR.rotation.x=-Math.PI/2; ewR.rotation.z=Math.PI/2; ewR.receiveShadow=true; ewR.renderOrder=0; scene.add(ewR); roads.push({mesh:ewR,orientation:'EW'});}}
        function updateRoads() { /* ... uses roadY ... */ const pGX=Math.round(planeState.position.x/ROAD_GRID_SPACING); const pGZ=Math.round(planeState.position.z/ROAD_GRID_SPACING); let nsI=0; let ewI=0; roads.forEach(rD=>{ const{mesh,orientation}=rD; if(orientation==='NS'){mesh.position.x=(pGX+nsI-1)*ROAD_GRID_SPACING; mesh.position.z=planeState.position.z; mesh.position.y=roadY; nsI++;} else {mesh.position.z=(pGZ+ewI-1)*ROAD_GRID_SPACING; mesh.position.x=planeState.position.x; mesh.position.y=roadY; ewI++;}}); }
        function spawnCar() { /* ... uses new mesh ... */ if (cars.length>=MAX_CARS) return; const car=createCarMesh(); car.position.y=car.userData.yOffset||0; const playerPos=planeState.position; const orientation=Math.random()<0.5?'NS':'EW'; const direction=Math.random()<0.5?1:-1; let spawnX,spawnZ; let velX=0,velZ=0; const playerGridX=Math.round(playerPos.x/ROAD_GRID_SPACING); const playerGridZ=Math.round(playerPos.z/ROAD_GRID_SPACING); const spawnSideOffset=(Math.random()-0.5)*ROAD_WIDTH*0.8; if(orientation==='NS'){ spawnX=playerGridX*ROAD_GRID_SPACING+spawnSideOffset; spawnZ=playerPos.z+direction*CAR_SPAWN_DISTANCE_AHEAD; velZ=-direction*CAR_SPEED; car.rotation.y=(direction>0)?Math.PI:0;} else { spawnX=playerPos.x+direction*CAR_SPAWN_DISTANCE_AHEAD; spawnZ=playerGridZ*ROAD_GRID_SPACING+spawnSideOffset; velX=-direction*CAR_SPEED; car.rotation.y=(direction>0)?Math.PI/2:-Math.PI/2;} car.position.x=spawnX; car.position.z=spawnZ; car.userData.velocity=new THREE.Vector3(velX,0,velZ); scene.add(car); cars.push(car);}
        function updateCars(dt) { /* ... unchanged logic ... */ const playerPos=planeState.position; for(let i=cars.length-1;i>=0;i--){ const car=cars[i]; if (!car||!car.userData||!car.userData.velocity){cars.splice(i,1); continue;} const vel=car.userData.velocity; car.position.x+=vel.x*dt; car.position.z+=vel.z*dt; const dz=Math.abs(car.position.z-playerPos.z); const dx=Math.abs(car.position.x-playerPos.x); let despawn=false; /* ... despawn logic ... */ if(vel.z!==0&&car.position.z>playerPos.z+CAR_DESPAWN_DISTANCE_BEHIND&&vel.z>0) despawn=true; if(vel.z!==0&&car.position.z<playerPos.z-CAR_SPAWN_DISTANCE_AHEAD*1.2&&vel.z<0) despawn=true; if(vel.x!==0&&car.position.x>playerPos.x+CAR_DESPAWN_DISTANCE_BEHIND&&vel.x>0) despawn=true; if(vel.x!==0&&car.position.x<playerPos.x-CAR_SPAWN_DISTANCE_AHEAD*1.2&&vel.x<0) despawn=true; if(dx>CAR_DESPAWN_DISTANCE_SIDE||dz>CAR_SPAWN_DISTANCE_AHEAD*1.5){ despawn=true;} if(despawn){ if (car.parent) scene.remove(car); cars.splice(i,1);}}}
        function spawnBird() { /* ... unchanged ... */ if (birds.length>=MAX_BIRDS) return; const bird=createBirdMesh(); const speed=BIRD_SPEED_MIN+Math.random()*(BIRD_SPEED_MAX-BIRD_SPEED_MIN); const dir=new THREE.Vector3(Math.random()-0.5,Math.random()*0.2-0.1,Math.random()-0.5).normalize(); bird.userData.velocity=dir.multiplyScalar(speed); const angle=Math.random()*Math.PI*2; const radius=Math.random()*BIRD_SPAWN_RADIUS; const sx=planeState.position.x+Math.cos(angle)*radius; const sz=planeState.position.z+Math.sin(angle)*radius; const sy=BIRD_SPAWN_ALT_MIN+Math.random()*(BIRD_SPAWN_ALT_MAX-BIRD_SPAWN_ALT_MIN); bird.position.set(sx,sy,sz); bird.lookAt(bird.position.clone().add(bird.userData.velocity)); scene.add(bird); birds.push(bird); }
        function updateBirds(dt, time) { /* ... unchanged ... */ for (let i=birds.length-1;i>=0;i--){ const bird=birds[i]; if (!bird||!bird.userData||!bird.userData.velocity){birds.splice(i,1); continue;} const vel=bird.userData.velocity; bird.position.add(vel.clone().multiplyScalar(dt)); if (bird.userData.wings){const flapAngle=Math.sin(time*BIRD_FLAP_SPEED)*0.6; bird.userData.wings[0].rotation.z=flapAngle; bird.userData.wings[1].rotation.z=-flapAngle;} const distance=bird.position.distanceTo(planeState.position); if(distance>BIRD_DESPAWN_RADIUS){ if (bird.parent) scene.remove(bird); bird.traverse(child=>{if(child.isMesh&&child.geometry)child.geometry.dispose();}); birds.splice(i,1);}}}

        // --- Shooting --- (Unchanged logic from v12)
        function handleShooting() { const now=performance.now(); if(now-lastShotTime<SHOOT_COOLDOWN) return; lastShotTime=now; spawnProjectile(); }
        function spawnProjectile() { if (!planeMesh) return; const projectile=new THREE.Mesh(projectileGeometry,projectileMaterial); const startOffset=new THREE.Vector3(0,0,-6); const startPos=startOffset.applyQuaternion(planeState.quaternion).add(planeState.position); projectile.position.copy(startPos); const forward=new THREE.Vector3(0,0,-1).applyQuaternion(planeState.quaternion); projectile.userData.velocity=forward.multiplyScalar(PROJECTILE_SPEED).add(planeState.velocity); projectile.userData.life=3.0; projectile.userData.startTime=clock.getElapsedTime(); scene.add(projectile); projectiles.push(projectile); }
        function updateProjectiles(dt) { for(let i=projectiles.length-1;i>=0;i--){ const p=projectiles[i]; if(!p||!p.userData){projectiles.splice(i,1); continue;} const lifeLived=clock.getElapsedTime()-p.userData.startTime; if(lifeLived>=p.userData.life){ if(p.parent) scene.remove(p); projectiles.splice(i,1);} else { p.position.add(p.userData.velocity.clone().multiplyScalar(dt));}}}

        // --- Update Environment (Includes Projectiles) --- (Unchanged from v12)
        function updateEnvironment(dt, time) { timeSinceLastScenerySpawn+=dt; timeSinceLastCloudSpawn+=dt; timeSinceLastBalloonSpawn+=dt; timeSinceLastCarSpawn+=dt; timeSinceLastBirdSpawn+=dt; const fVec=new THREE.Vector3(0,0,-1).applyQuaternion(planeState.quaternion); if(timeSinceLastScenerySpawn>SCENERY_SPAWN_INTERVAL){const pAh=planeState.position.clone().add(fVec.clone().multiplyScalar(SCENERY_SPAWN_DISTANCE)); const sX=pAh.x+(Math.random()-0.5)*SCENERY_AREA_WIDTH; const sZ=pAh.z+(Math.random()-0.5)*SCENERY_AREA_WIDTH*0.5; spawnSceneryObject(new THREE.Vector3(sX,0,sZ)); timeSinceLastScenerySpawn=0;} sceneryObjects=sceneryObjects.filter(obj=>{ if(!obj) return false; const vTo=obj.position.clone().sub(planeState.position); const d=vTo.length(); const dot=vTo.dot(fVec); if(d>SCENERY_SPAWN_DISTANCE*1.2||(dot<0&&d>SCENERY_DESPAWN_DISTANCE)){ if(obj.parent) scene.remove(obj); if(obj.isMesh){if(obj.userData.type==='skyscraper'&&obj.geometry) obj.geometry.dispose();}else if(obj.isGroup){obj.traverse(c=>{if(c.isMesh&&c.geometry)c.geometry.dispose();});} return false;} return true;}); if(timeSinceLastCloudSpawn>CLOUD_SPAWN_INTERVAL){spawnCloud(); timeSinceLastCloudSpawn=0;} clouds=clouds.filter(cld=>{if(!cld) return false; const d=cld.position.distanceTo(planeState.position); if(d>CLOUD_DESPAWN_RADIUS){if(cld.parent) scene.remove(cld);return false;} return true;}); if(timeSinceLastBalloonSpawn>BALLOON_SPAWN_INTERVAL){spawnBalloon(); timeSinceLastBalloonSpawn=0;} balloons=balloons.filter(bal=>{if(!bal) return false; const d=bal.position.distanceTo(planeState.position); if(d>BALLOON_DESPAWN_RADIUS){if(bal.parent) scene.remove(bal); return false;} return true;}); if(timeSinceLastCarSpawn>CAR_SPAWN_INTERVAL){spawnCar(); timeSinceLastCarSpawn=0;} if(timeSinceLastBirdSpawn>BIRD_SPAWN_INTERVAL){spawnBird(); timeSinceLastBirdSpawn=0;} updateRoads(); updateCars(dt); updateBirds(dt, time); updateProjectiles(dt); }

        // --- Explosion Effect --- (Unchanged)
        function createExplosion(position) { /* ... */ const particleCount=30; const speed=40; for(let i=0;i<particleCount;i++){const particle=new THREE.Mesh(explosionGeometry,explosionMaterial.clone()); particle.position.copy(position); particle.userData.velocity=new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize().multiplyScalar(speed*(Math.random()*0.5+0.5)); particle.userData.life=0.8+Math.random()*0.4; particle.userData.startTime=clock.getElapsedTime(); scene.add(particle); explosionParticles.push(particle);}}
        function updateExplosions(dt) { /* ... */ for(let i=explosionParticles.length-1;i>=0;i--){ const particle=explosionParticles[i]; if (!particle||!particle.userData){explosionParticles.splice(i,1); continue;} const lifeLived=clock.getElapsedTime()-particle.userData.startTime; if(lifeLived>=particle.userData.life){ if(particle.parent) scene.remove(particle); if(particle.material) particle.material.dispose(); explosionParticles.splice(i,1);} else { particle.position.add(particle.userData.velocity.clone().multiplyScalar(dt)); particle.userData.velocity.y-=GRAVITY*2*dt; particle.material.opacity=Math.max(0,(particle.userData.life-lifeLived)/particle.userData.life*0.8); const scale=Math.max(0.1,(particle.userData.life-lifeLived)/particle.userData.life); particle.scale.set(scale,scale,scale);}}}

        // --- Collision Detection --- (Unchanged logic from v12)
        function checkCollisions() { if(!planeMesh || !planeMesh.visible || gameState !== 'playing') return false; const planeCenterOffset = new THREE.Vector3(0, 0, -1); const worldPlaneCenter = planeCenterOffset.applyQuaternion(planeState.quaternion).add(planeState.position); planeCollisionBox.setFromCenterAndSize(worldPlaneCenter, PLANE_BOX_SIZE); let fatalCollisionDetected = false; let collisionObject = null; for (const obj of sceneryObjects) { if (!obj) continue; objectBox.setFromObject(obj, true); if (planeCollisionBox.intersectsBox(objectBox)) { fatalCollisionDetected = true; collisionObject = obj.userData.type || 'scenery'; break; }} if (!fatalCollisionDetected) { for (const car of cars) { if (!car) continue; objectBox.setFromObject(car); if (planeCollisionBox.intersectsBox(objectBox)) { fatalCollisionDetected = true; collisionObject = 'car'; break; }}} if (!fatalCollisionDetected) { const birdColRad = 3; for (let i=birds.length-1; i>=0; i--) { const bird = birds[i]; if (!bird) continue; const d = planeState.position.distanceTo(bird.position); if (d < PLANE_COLLISION_RADIUS + birdColRad) { fatalCollisionDetected = true; collisionObject = 'bird'; createExplosion(bird.position); if (bird.parent) scene.remove(bird); birds.splice(i, 1); break; }}} if (fatalCollisionDetected) { handleCrash(); return true; } const balloonHitThresh = balloonGeometry.parameters.radius + PLANE_COLLISION_RADIUS; for(let i = balloons.length - 1; i >= 0; i--) { const bal = balloons[i]; if (!bal) continue; const d = planeState.position.distanceTo(bal.position); if (d < balloonHitThresh) { score += POINTS_PER_BALLOON_HIT; updateScoreDisplay(); createExplosion(bal.position); if (bal.parent) scene.remove(bal); balloons.splice(i, 1); }} const projHitRad = 1.0; for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; if (!p) continue; let projectileHit = false; projectileBox.setFromObject(p); for (let j = balloons.length - 1; j >= 0; j--) { const bal = balloons[j]; if (!bal) continue; objectBox.setFromObject(bal); if (projectileBox.intersectsBox(objectBox)) { score += POINTS_PER_BALLOON_SHOT; updateScoreDisplay(); createExplosion(bal.position); if (bal.parent) scene.remove(bal); balloons.splice(j, 1); projectileHit = true; break; }} if (projectileHit) { if (p.parent) scene.remove(p); projectiles.splice(i, 1); continue; } const birdHitBoxScale = 1.5; for (let j = birds.length - 1; j >= 0; j--) { const bird = birds[j]; if (!bird) continue; objectBox.setFromObject(bird).expandByScalar(birdHitBoxScale); if (projectileBox.intersectsBox(objectBox)) { score += POINTS_PER_BIRD_SHOT; updateScoreDisplay(); createExplosion(bird.position); if (bird.parent) scene.remove(bird); birds.splice(j, 1); projectileHit = true; break; }} if (projectileHit) { if (p.parent) scene.remove(p); projectiles.splice(i, 1); } } return false; }

        // --- Crash Handling --- (Unchanged)
        function handleCrash() { if(gameState!=='playing') return; gameState='crashed'; lives--; updateLivesDisplay(); console.log(`Crash! Lives left: ${lives}`); if(planeMesh) planeMesh.visible=false; planeState.velocity.set(0,0,0); planeState.pitchSpeed=0; planeState.rollSpeed=0; planeState.yawSpeed=0; createExplosion(planeState.position); if(lives<=0){ gameState='gameover'; showGameOver(); } else { setTimeout(resetAfterCrash, CRASH_RESET_DELAY); } }

        // --- High Score Functions --- (Unchanged)
        function loadHighScores() { const scoresJSON = localStorage.getItem(HIGH_SCORE_KEY); return scoresJSON ? JSON.parse(scoresJSON) : []; }
        function saveHighScores() { localStorage.setItem(HIGH_SCORE_KEY, JSON.stringify(highScores)); }
        function isHighScore(newScore) { if (highScores.length < 5) return true; return newScore > highScores[highScores.length - 1].score; }
        function addHighScore(newName, newScore) { highScores.push({ name: newName, score: newScore }); highScores.sort((a, b) => b.score - a.score); highScores = highScores.slice(0, 5); saveHighScores(); }
        function displayHighScores() { highScoreList.innerHTML = ''; if (highScores.length === 0) { highScoreList.innerHTML = '<li>No scores yet!</li>'; } else { highScores.forEach(scoreItem => { const li = document.createElement('li'); const nameSpan = document.createElement('span'); nameSpan.textContent = scoreItem.name; const scoreSpan = document.createElement('span'); scoreSpan.textContent = scoreItem.score; li.appendChild(nameSpan); li.appendChild(scoreSpan); highScoreList.appendChild(li); }); } }

        // --- Game State Functions --- (Unchanged)
        function resetAfterCrash() { if(gameState==='gameover') return; console.log("Resetting after crash..."); resetPlaneState(); if(planeMesh) planeMesh.visible=true; gameState='playing'; }
        function showGameOver() { console.log("Game Over"); finalScoreValue.textContent=score; displayHighScores(); gameOverOverlay.style.display='flex'; if (isHighScore(score)) { setTimeout(() => { const playerName = prompt(`New High Score! Enter your name (3 chars):`, "AAA"); if (playerName && playerName.trim()) { addHighScore(playerName.trim().substring(0, 3).toUpperCase(), score); displayHighScores(); } }, 100); } }
        function hideGameOver() { gameOverOverlay.style.display='none'; }
        function restartGame() { console.log("START: restartGame()"); hideGameOver(); setInitialGameState(); clearDynamicObjects(); gameState='playing'; console.log("END: restartGame()"); }
        function setInitialGameState() { console.log("Setting initial game state..."); score = 0; lives = 3; updateScoreDisplay(); updateLivesDisplay(); resetPlaneState(); if (planeMesh) { planeMesh.visible = true; } gameState = 'playing'; updateInfo(); }
        function resetPlaneState() { console.log("Resetting plane state (physics)..."); planeState.position.set(0, MIN_ALTITUDE + START_ALTITUDE, 0); planeState.velocity.set(0, 0, -INITIAL_FORWARD_SPEED); planeState.quaternion.identity(); planeState.thrust = 1.0; planeState.speed = INITIAL_FORWARD_SPEED; planeState.pitchSpeed = 0; planeState.rollSpeed = 0; planeState.yawSpeed = 0; if(planeMesh){ planeMesh.position.copy(planeState.position); planeMesh.quaternion.copy(planeState.quaternion); } }
        function clearDynamicObjects() { console.log("Clearing dynamic objects..."); [sceneryObjects, clouds, balloons, cars, birds, explosionParticles, projectiles].forEach(arr => { try { arr.forEach(obj => { if (obj && obj.parent) scene.remove(obj); }); arr.length = 0; } catch (e) { console.error("Error clearing objects:", e); } }); timeSinceLastScenerySpawn=0; timeSinceLastCloudSpawn=0; timeSinceLastBalloonSpawn=0; timeSinceLastCarSpawn=0; timeSinceLastBirdSpawn=0; console.log("Dynamic objects cleared."); }


        // --- Event Handlers & Updates ---

        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); }

        // --- Update Physics --- << CORRECTED STRAFE LOGIC & FORCE >>
        function updatePhysics(dt) {
            const isOnGround = planeState.position.y <= MIN_ALTITUDE + 0.01;
            let pIn=0; let rIn=0; let yawInputGround=0; let crabInput=0;

            if(keysPressed['KeyW']) planeState.thrust=Math.min(1.0,planeState.thrust+dt*0.7); if(keysPressed['KeyS']) planeState.thrust=Math.max(0.0,planeState.thrust-dt*0.9);
            if(keysPressed['ArrowUp']) pIn=-1; if(keysPressed['ArrowDown']) pIn=1;

            // Check Strafe/Taxi/Roll
            if (!isOnGround && keysPressed['KeyC']) { // Strafe only in air
                 if(keysPressed['ArrowLeft']) crabInput = -1;
                 if(keysPressed['ArrowRight']) crabInput = 1;
                 rIn = 0; // No roll input when strafing
            } else { // Normal Roll or Taxi
                if(keysPressed['ArrowLeft']) rIn=1;
                if(keysPressed['ArrowRight']) rIn=-1;
                if (isOnGround) { if(keysPressed['KeyA']) yawInputGround = 1; if(keysPressed['KeyD']) yawInputGround = -1; }
            }

            // Angular Velocity
            planeState.pitchSpeed+=pIn*PITCH_CONTROL_RATE;
            planeState.rollSpeed+=rIn*ROLL_CONTROL_RATE; // Only applies if not strafing
            if(isOnGround){ planeState.yawSpeed+=yawInputGround*TAXI_YAW_RATE;}
            else if (crabInput === 0) { planeState.yawSpeed-=planeState.rollSpeed*YAW_FROM_ROLL_FACTOR; } // Yaw from roll only if not strafing

            // Damping
            planeState.pitchSpeed*=ANGULAR_DAMPING; planeState.rollSpeed*=ANGULAR_DAMPING; planeState.yawSpeed*=ANGULAR_DAMPING;

            // Ground Leveling
            if(isOnGround){const euler=new THREE.Euler().setFromQuaternion(planeState.quaternion,'YXZ'); const ctrlFactor=1.0-Math.min(1.0,Math.abs(pIn)+Math.abs(rIn)); planeState.pitchSpeed-=euler.x*GROUND_LEVELING_FACTOR*ctrlFactor; planeState.rollSpeed-=euler.z*GROUND_LEVELING_FACTOR*ctrlFactor;}

            // Clamp near zero
            if(Math.abs(planeState.pitchSpeed)<0.0001) planeState.pitchSpeed=0; if(Math.abs(planeState.rollSpeed)<0.0001) planeState.rollSpeed=0; if(Math.abs(planeState.yawSpeed)<0.0001) planeState.yawSpeed=0;

            // Update Rotation
            const dP=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),planeState.pitchSpeed*dt); const dR=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1),planeState.rollSpeed*dt); const dY=new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0),planeState.yawSpeed*dt);
            planeState.quaternion.premultiply(dY); planeState.quaternion.multiply(dP); planeState.quaternion.multiply(dR); planeState.quaternion.normalize();

            // Forces
            const fwd=new THREE.Vector3(0,0,-1).applyQuaternion(planeState.quaternion); const up=new THREE.Vector3(0,1,0).applyQuaternion(planeState.quaternion); const right=new THREE.Vector3(1,0,0).applyQuaternion(planeState.quaternion); // Get local right vector again
            const spdSq=planeState.velocity.lengthSq(); const thrF=fwd.clone().multiplyScalar(planeState.thrust*MAX_THRUST_FORCE); const drgF=planeState.velocity.clone().negate().multiplyScalar(DRAG_COEFFICIENT*spdSq); let liftMag=0; const locVel=planeState.velocity.clone().applyQuaternion(planeState.quaternion.clone().invert()); const relSpdSq=locVel.z*locVel.z+locVel.x*locVel.x; if(relSpdSq>MIN_SPEED_FOR_LIFT*MIN_SPEED_FOR_LIFT){ const liftFct=Math.max(0.0,up.y); liftMag=relSpdSq*LIFT_COEFFICIENT*liftFct;} const liftF=up.clone().multiplyScalar(liftMag); const gravF=new THREE.Vector3(0,-GRAVITY,0);
            const crabForceVec = right.multiplyScalar(crabInput * CRAB_FORCE * dt); // Calculate actual force vector for strafe

            // Integration
            const totF=new THREE.Vector3().add(thrF).add(drgF).add(liftF); // Base forces
            if(!isOnGround||planeState.velocity.y>0){ totF.add(gravF); } // Add gravity if needed

            // Apply Total Force (including base drag/lift/thrust/gravity)
            planeState.velocity.add(totF.clone().multiplyScalar(dt));

            // Apply Crab Force Directly to Velocity (more immediate effect for arcade feel)
            if (crabInput !== 0 && !isOnGround) {
                 planeState.velocity.add(crabForceVec); // Add the calculated strafe impulse
            }

            // Update Position from Velocity
            planeState.position.add(planeState.velocity.clone().multiplyScalar(dt));

            // Ground Constraint
            if(planeState.position.y<=MIN_ALTITUDE&&planeState.velocity.y<=0){ planeState.position.y=MIN_ALTITUDE; if(planeState.velocity.y<0){ planeState.velocity.y=0;} planeState.velocity.x*=GROUND_FRICTION; planeState.velocity.z*=GROUND_FRICTION; }

            // Update Mesh & Speed
            if(planeMesh&&planeMesh.visible){ planeMesh.position.copy(planeState.position); planeMesh.quaternion.copy(planeState.quaternion); }
            planeState.speed=planeState.velocity.length();
        }

        // --- updateCamera, updateScoreDisplay, updateLivesDisplay, updateInfo --- (Unchanged)
        function updateCamera(dt) { if (!camera || !planeMesh) return; const camOff=new THREE.Vector3(0,5,15); const wOff=camOff.clone().applyQuaternion(planeState.quaternion); const tCamPos=planeState.position.clone().add(wOff); const lerpF=Math.min(dt*3.5,1.0); camera.position.lerp(tCamPos,lerpF); const lookOff=new THREE.Vector3(0,1,-10); const wLook=lookOff.clone().applyQuaternion(planeState.quaternion).add(planeState.position); camera.lookAt(wLook); if(groundMesh) { groundMesh.position.x=planeState.position.x; groundMesh.position.z=planeState.position.z;} const l=scene.children.find(c=>c instanceof THREE.DirectionalLight); if(l&&l.castShadow){l.target.position.copy(planeState.position); l.position.copy(planeState.position).add(new THREE.Vector3(100,150,100)); l.target.updateMatrixWorld();} }
        function updateScoreDisplay() { scoreDisplay.textContent=score; }
        function updateLivesDisplay() { livesDisplay.textContent = lives; }
        function updateInfo() { altitudeDisplay.textContent=Math.max(0,planeState.position.y-MIN_ALTITUDE).toFixed(1); speedDisplay.textContent=planeState.speed.toFixed(1); thrustDisplay.textContent=(planeState.thrust*100).toFixed(0); }

        // --- Animation Loop --- (Unchanged from v11.2)
        function animate() { let rafId = requestAnimationFrame(animate); const dt = clock.getDelta(); const time = clock.getElapsedTime(); if(dt > 0.1 || dt <= 0) return; try { if (gameState === 'playing') { updatePhysics(dt); checkCollisions(); updateEnvironment(dt, time); } updateCamera(dt); updateExplosions(dt); updateInfo(); if (renderer && scene && camera) { renderer.render(scene, camera); } else { console.error("Rendering components missing!"); cancelAnimationFrame(rafId); } } catch (error) { console.error("Error in animation loop:", error); } }

        // --- Start ---
        init();

    </script>
</body>
</html>